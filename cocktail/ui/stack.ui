<?xml version="1.0" encoding="utf-8"?>

<div
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:ui="http://www.whads.com/ns/cocktail/ui">

    <?head
    const STACK_TOP = Symbol("cocktail.ui.Stack.STACK_TOP");
    const STACK_PARENT = Symbol("cocktail.ui.Stack.STACK_PARENT");
    ?>

    <?class
    push(element) {

        let stackNode = this.constructor.StackNode.create();
        stackNode.stackNodeContent.appendChild(element);

        let stackTop = this[STACK_TOP];

        if (stackTop) {
            stackTop.stackDescendants.appendChild(stackNode);
            stackNode[STACK_PARENT] = stackTop;
        }
        else {
            this.stackContent.appendChild(stackNode);
        }

        this[STACK_TOP] = stackNode;
        cocktail.ui.trigger(this, "stackNodePushed", {stackNode});
        return stackNode;
    }

    pop(stackNode = null) {
        if (!stackNode) {
            stackNode = this[STACK_TOP];
        }

        if (!stackNode) {
            throw new this.constructor.StackError();
        }

        stackNode.addEventListener("animationend", (e) => {
            let stackParent = stackNode[STACK_PARENT];
            if (stackParent) {
                stackParent.stackDescendants.removeChild(stackNode);
            }
            else {
                this.stackContent.removeChild(stackNode);
            }
            this[STACK_TOP] = stackParent;

            let triggerPoppedEvent = (node) => {
                if (node.stackChild) {
                    triggerPoppedEvent(node.stackChild);
                }
                cocktail.ui.trigger(this, "stackNodePopped", {stackNode: node});
            }
            triggerPoppedEvent(stackNode);

            if (!stackParent) {
                cocktail.ui.trigger(this, "stackEmptied");
            }
        });
        stackNode.animationState = "closing";

        return stackNode;
    }

    clearStack() {
        while (this[STACK_TOP]) {
            this.pop();
        }
    }

    *iterStack() {
        let node = this.stackRoot;
        while (node) {
            yield node;
            node = node.stackChild;
        }
    }

    get stackRoot() {
        return this.stackContent.firstChild;
    }

    get stackTop() {
        return this[STACK_TOP];
    }
    ?>

    <?tail
    cls.StackError = class StackError {
        toString() {
            return "Can't pop from an empty stack";
        }
    }
    ?>

    <div id="stackContent"/>

    <div ui:component="StackNode">

        <ui:property
            name="animationState"
            type="string"
            reflected="true"
            default="opening"/>

        <?class
        get stackParent() {
            return this[STACK_PARENT];
        }

        get stackChild() {
            return this.stackDescendants.firstChild;
        }

        get stackElement() {
            return this.stackNodeContent.firstChild;
        }
        ?>

        <?on animationend
        if (this.animationState == "opening") {
            this.animationState = "none";
        }
        ?>

        <div id="stackNodeContent"/>
        <div id="stackDescendants"/>
    </div>

</div>

